## 문제 분석 
이 문제는 주어진 금액을 만들 수 있고 가장 적은 동전 개수일 때 그 개수를 리턴하는 문제이다. 
이 문제는 그리디 문제가 아니다. 예를 들어, [1, 6, 7, 10] 이고 13 금액을 채워야한다고 해보자. 10을 쓴다면 1을 2번 써야지 금액을 채워진다. 따라서 3개가 필요하다. 하지만 6, 7을 사용하면 2개가 필요하므로 2개가 정답이 된다. 

따라서 모든 경우의 수를 알 필요가 있다. 따라서 처음에는 재귀를 사용하기로 생각했다. 먼저 동전 배열을 내림차순으로 정렬하고 해당 수부터 차례대로 몫 부터 0까지 순환을 하며 재귀를 사용하는 것이다. 하지만 이 방식은 시간초과가 발생한다. 각 호출에 대해서 최대 C 개의 동전에 대해 재귀 호출을 수행한다. 

T(A)=C×T(A−C)

동전의 값이 1이면 최대 A(Amount)번 재귀를 수행해야 한다. 
지수 시간복잡도 O(C^A) 인 것이다. 특히 Amount가 많을 수록 시간복잡도에 치명적인데 Amount은 최대 10^4를 가질 수 있다. 이미 기각이다...  따라서 시간복잡도 초과가 발생했다. 


그렇다면 어떻게 이를 줄일 수 있을까? 최대한 반복되는 것을 줄이면 해결할 수 있을 것이다. 
[1, 3, 6, 7, 10, 30] 80 이라고 해보자. 매 가능한 횟수마다 구하는게 아니라 예를 들어 10의 최솟값을 저장하면 그걸 다시 사용하는 것이다. 
10은 1로 10개, 1 + 3 * 3, 1 + 3 + 6, 3 + 7, 10으로 만들 수 있지만 10이 필요한 매 순간마다 이를 구하는 것은 매우 비효율적이다. 이를 10을 사용하여 즉 개수 1개가 최소값인걸 저장한다면 그것만 확인하면 될 일이다. 

이를 메모제이션이라고 한다. 시간 복잡도를 줄이고 공간복잡도를 높여 해결하는 것이다. 

1부터 목표 금액까지의 순서대로 탐색한다. 그리고 해당 금액을 만들 수 있는 동전의 개수를 저장하는 것이다. 저장할 땐 최솟값을 저장한다. 그리고 그 금액의 최솟값을 활용하여 현재 금액의 최솟값을 더해서 구하는 것이다. 

```swift
var dp: [Int] = Array(repeating: -1, count: Amount + 1)
dp[0] = 0
for i in 1...Amount {
    for coin in coins {
        if coin > i { break }
        if dp[i - coin] == -1 { continue }
        dp[i] = dp[i] == -1 ? dp[i - coin] + 1 : min(dp[i], dp[i - coin] + 1)
    }
}

```
