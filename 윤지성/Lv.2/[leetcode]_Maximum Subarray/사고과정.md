## 문제 
- 난이도: medium 
Given an integer array nums, find the subarray with the largest sum, and return its sum.
Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

 

Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]


## 문제 분석 
이 문제는 배열 안에서 합이 가장 큰 부분 배열의 합을 리턴하는 것이다. 이때 여기서 말하는 부분 배열은 배열 내에서 연속적으로 존재하는 부분배열을 말한다. 
따라서 배열에서 연속적인 숫자의 모음에서 가장 큰 합을 리턴하는 것이라고 이해하면 된다. 

## 해결 방식 
### 1번째 제출 사고 방식 

처음에 내가 생각했던 방식은 다음과 같다. 
연속적으로 같은 부호의 수가 있는 경우 (음수, 음수 혹은 양수, 양수) 합하여 새로운 배열을 세팅하는 것이다. 
그 전의 부분 배열의 합에 현재의 수를 더했을 때 부분 배열의 합이 그 수의 값 보다 작다면 해당 부분 배열은 최댓값이 될 수 없다. 
따라서 부분 배열을 유지할 필요도 없는 것이다. 

나는 이 부분을 조금 복잡하게 작성했다. 
내가 초기 세팅을 하는 과정에서 같은 부호의 수를 더해서 새로운 배열을 세팅하는 과정이 있었다. 이 과정에서 문제점이 있다. 만약 음수로만 이루어져 있다면? 이 방식으로는 최댓값을 구하지는 못한다. 

처음부터 완벽한 방식은 존재하지 않는다. 내가 문제 해결방식을 간구한 후 거기에 대한 예외를 많이 생각하는 과정을 추가해야 겠다. 
예외를 생각하면 내가 빼먹은 조건이나 상황이 뭔지 알아낼 수 있기 때문이다. 

앞으로는 알고리즘 생각 -> 예시에 적용하기 -> 로직 짜기 -> 예외 생각하기 -> 그게 통과하는지 확인하기 -> 해당 문제 풀이를 간단화할 수 있는지 (선택) 이런식으로 진행해 봐야겠다. 
 
### 2번째 제출 사고 방식 
문제 풀이를 간단화할 수 있는지 확인해봤다. 
일단 세팅과정이 필요없을 뿐더러 탐색 전에 max값과 부분 배열의 합을 첫번째 원소 값으로 지정한다. 
또한 그 전의 부분 배열의 합에 현재의 수를 더했을 때 부분 배열의 합이 그 수의 값 보다 작다면 부분 배열을 그 수로 초기화한다. 
그리고 매 탐색마다 max와 현재 부분 배열의 합을 비교하여 max 값을 갱신한다. 

이런 식으로 이동되면 매우 간단해지는 풀이가 만들어진다. 
